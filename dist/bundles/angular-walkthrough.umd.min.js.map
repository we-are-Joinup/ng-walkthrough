{"version":3,"file":"angular-walkthrough.umd.min.js","sources":["../../build/walkthrough-tools.ts","../../node_modules/tslib/tslib.es6.js","../../node_modules/src/cdk/portal/portal-errors.ts","../../node_modules/src/cdk/portal/portal.ts","../../node_modules/src/cdk/portal/dom-portal-outlet.ts","../../node_modules/src/cdk/portal/portal-directives.ts","../../node_modules/src/cdk/portal/portal-injector.ts","../../build/walkthrough.service.ts","../../build/walkthrough-text.ts","../../build/walkthrough-container.component.ts","../../build/walkthrough.component.ts","../../build/walkthrough-flow.component.ts","../../build/walkthrough.module.ts"],"sourcesContent":["import { WalkthroughComponent } from './walkthrough.component';\n\nexport interface WalkthroughElementCoordinate {\n    top: number;\n    left: number;\n    height: number;\n    width: number;\n    margin: Margin;\n}\nexport interface Margin {\n    top: number;\n    left: number;\n    right: number;\n    bottom: number;\n}\n\nexport const booleanValue = (value: string | boolean) => {\n    return value === 'true' || value === true;\n};\n\nexport class WalkthroughEvent {\n    constructor(\n        public component: WalkthroughComponent,\n        public focusElement: HTMLElement\n    ) { }\n}\n\nexport class WalkthroughMargin {\n\n    static parsePoints(points: string): WalkthroughMargin {\n        let pointsPx: WalkthroughMargin;\n        if (points.match(/^\\d+(?:\\s+\\d+)*$/)) {\n            const split = points.split(/\\s+/).map(i => parseFloat(i));\n            pointsPx = new WalkthroughMargin(split[0], split[1], split[2], split[3]);\n        }\n        return pointsPx || new WalkthroughMargin();\n    }\n\n    constructor(\n        public top = 0,\n        public right?: number,\n        public bottom?: number,\n        public left?: number,\n    ) {\n        if (right === undefined) {\n            this.right = top;\n        }\n        if (bottom === undefined) {\n            this.bottom = top;\n        }\n        if (left === undefined && right === undefined) {\n            this.left = top;\n        } else if (left === undefined) {\n            this.left = right;\n        }\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nexport function throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nexport function throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nexport function throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nexport function throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n              'a ComponentPortal or a TemplatePortal.');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nexport function throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nexport function throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n    TemplateRef,\n    ViewContainerRef,\n    ElementRef,\n    ComponentRef,\n    EmbeddedViewRef,\n    Injector\n} from '@angular/core';\nimport {\n    throwNullPortalOutletError,\n    throwPortalAlreadyAttachedError,\n    throwNoPortalAttachedError,\n    throwNullPortalError,\n    throwPortalOutletAlreadyDisposedError,\n    throwUnknownPortalTypeError\n} from './portal-errors';\n\n/** Interface that can be used to generically type a class. */\nexport interface ComponentType<T> {\n  new (...args: any[]): T;\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nexport abstract class Portal<T> {\n  private _attachedHost: PortalOutlet | null;\n\n  /** Attach this portal to a host. */\n  attach(host: PortalOutlet): T {\n    if (host == null) {\n      throwNullPortalOutletError();\n    }\n\n    if (host.hasAttached()) {\n      throwPortalAlreadyAttachedError();\n    }\n\n    this._attachedHost = host;\n    return <T> host.attach(this);\n  }\n\n  /** Detach this portal from its host */\n  detach(): void {\n    let host = this._attachedHost;\n\n    if (host == null) {\n      throwNoPortalAttachedError();\n    } else {\n      this._attachedHost = null;\n      host.detach();\n    }\n  }\n\n  /** Whether this portal is attached to a host. */\n  get isAttached(): boolean {\n    return this._attachedHost != null;\n  }\n\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host: PortalOutlet | null) {\n    this._attachedHost = host;\n  }\n}\n\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nexport class ComponentPortal<T> extends Portal<ComponentRef<T>> {\n  /** The type of the component that will be instantiated for attachment. */\n  component: ComponentType<T>;\n\n  /**\n   * [Optional] Where the attached component should live in Angular's *logical* component tree.\n   * This is different from where the component *renders*, which is determined by the PortalOutlet.\n   * The origin is necessary when the host is outside of the Angular application context.\n   */\n  viewContainerRef?: ViewContainerRef | null;\n\n  /** [Optional] Injector used for the instantiation of the component. */\n  injector?: Injector | null;\n\n  constructor(\n      component: ComponentType<T>,\n      viewContainerRef?: ViewContainerRef | null,\n      injector?: Injector | null) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n  }\n}\n\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nexport class TemplatePortal<C = any> extends Portal<C> {\n  /** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef: TemplateRef<C>;\n\n  /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef: ViewContainerRef;\n\n  /** Contextual data to be passed in to the embedded view. */\n  context: C | undefined;\n\n  constructor(template: TemplateRef<C>, viewContainerRef: ViewContainerRef, context?: C) {\n    super();\n    this.templateRef = template;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n  }\n\n  get origin(): ElementRef {\n    return this.templateRef.elementRef;\n  }\n\n  /**\n   * Attach the the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host: PortalOutlet, context: C | undefined = this.context): C {\n    this.context = context;\n    return super.attach(host);\n  }\n\n  detach(): void {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n\n\n/** A `PortalOutlet` is an space that can contain a single `Portal`. */\nexport interface PortalOutlet {\n  /** Attaches a portal to this outlet. */\n  attach(portal: Portal<any>): any;\n\n  /** Detaches the currently attached portal from this outlet. */\n  detach(): any;\n\n  /** Performs cleanup before the outlet is destroyed. */\n  dispose(): void;\n\n  /** Whether there is currently a portal attached to this outlet. */\n  hasAttached(): boolean;\n}\n\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nexport abstract class BasePortalOutlet implements PortalOutlet {\n  /** The portal currently attached to the host. */\n  protected _attachedPortal: Portal<any> | null;\n\n  /** A function that will permanently dispose this host. */\n  private _disposeFn: (() => void) | null;\n\n  /** Whether this host has already been permanently disposed. */\n  private _isDisposed: boolean = false;\n\n  /** Whether this host has an attached portal. */\n  hasAttached(): boolean {\n    return !!this._attachedPortal;\n  }\n\n  attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n  attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n  attach(portal: any): any;\n\n  /** Attaches a portal. */\n  attach(portal: Portal<any>): any {\n    if (!portal) {\n      throwNullPortalError();\n    }\n\n    if (this.hasAttached()) {\n      throwPortalAlreadyAttachedError();\n    }\n\n    if (this._isDisposed) {\n      throwPortalOutletAlreadyDisposedError();\n    }\n\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n    }\n\n    throwUnknownPortalTypeError();\n  }\n\n  abstract attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n\n  abstract attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n\n  /** Detaches a previously attached portal. */\n  detach(): void {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n\n    this._invokeDisposeFn();\n  }\n\n  /** Permanently dispose of this portal host. */\n  dispose(): void {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n\n  /** @docs-private */\n  setDisposeFn(fn: () => void) {\n    this._disposeFn = fn;\n  }\n\n  private _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  EmbeddedViewRef,\n  ApplicationRef,\n  Injector,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, TemplatePortal} from './portal';\n\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nexport class DomPortalOutlet extends BasePortalOutlet {\n  constructor(\n      /** Element into which the content is projected. */\n      public outletElement: Element,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _appRef: ApplicationRef,\n      private _defaultInjector: Injector) {\n    super();\n  }\n\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    let componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n    let componentRef: ComponentRef<T>;\n\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(\n          componentFactory,\n          portal.viewContainerRef.length,\n          portal.injector || portal.viewContainerRef.parentInjector);\n\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        this._appRef.detachView(componentRef.hostView);\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n\n    return componentRef;\n  }\n\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n    viewRef.detectChanges();\n\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n\n    this.setDisposeFn((() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    }));\n\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose(): void {\n    super.dispose();\n    if (this.outletElement.parentNode != null) {\n      this.outletElement.parentNode.removeChild(this.outletElement);\n    }\n  }\n\n  /** Gets the root HTMLElement for an instantiated component. */\n  private _getComponentRootNode(componentRef: ComponentRef<any>): HTMLElement {\n    return (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  NgModule,\n  ComponentRef,\n  Directive,\n  EmbeddedViewRef,\n  TemplateRef,\n  ComponentFactoryResolver,\n  ViewContainerRef,\n  OnDestroy,\n  OnInit,\n  Input,\n  EventEmitter,\n  Output,\n} from '@angular/core';\nimport {Portal, TemplatePortal, ComponentPortal, BasePortalOutlet} from './portal';\n\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n@Directive({\n  selector: '[cdk-portal], [cdkPortal], [portal]',\n  exportAs: 'cdkPortal',\n})\nexport class CdkPortal extends TemplatePortal {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\n/**\n * Possible attached references to the CdkPortalOutlet.\n */\nexport type CdkPortalOutletAttachedRef = ComponentRef<any> | EmbeddedViewRef<any> | null;\n\n\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n@Directive({\n  selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n  exportAs: 'cdkPortalOutlet, cdkPortalHost',\n  inputs: ['portal: cdkPortalOutlet']\n})\nexport class CdkPortalOutlet extends BasePortalOutlet implements OnInit, OnDestroy {\n  /** Whether the portal component is initialized. */\n  private _isInitialized = false;\n\n  /** Reference to the currently-attached component/view ref. */\n  private _attachedRef: CdkPortalOutletAttachedRef;\n\n  constructor(\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _viewContainerRef: ViewContainerRef) {\n    super();\n  }\n\n  /**\n   * @deprecated\n   * @deletion-target 6.0.0\n   */\n  @Input('portalHost')\n  get _deprecatedPortal() { return this.portal; }\n  set _deprecatedPortal(v) { this.portal = v; }\n\n  /**\n   * @deprecated\n   * @deletion-target 6.0.0\n   */\n  @Input('cdkPortalHost')\n  get _deprecatedPortalHost() { return this.portal; }\n  set _deprecatedPortalHost(v) { this.portal = v; }\n\n  /** Portal associated with the Portal outlet. */\n  get portal(): Portal<any> | null {\n    return this._attachedPortal;\n  }\n\n  set portal(portal: Portal<any> | null) {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n\n    if (this.hasAttached()) {\n      super.detach();\n    }\n\n    if (portal) {\n      super.attach(portal);\n    }\n\n    this._attachedPortal = portal;\n  }\n\n  @Output('attached') attached: EventEmitter<CdkPortalOutletAttachedRef> =\n      new EventEmitter<CdkPortalOutletAttachedRef>();\n\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef(): CdkPortalOutletAttachedRef {\n    return this._attachedRef;\n  }\n\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedPortal = null;\n    this._attachedRef = null;\n  }\n\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    portal.setAttachedHost(this);\n\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef = portal.viewContainerRef != null ?\n        portal.viewContainerRef :\n        this._viewContainerRef;\n\n    const componentFactory =\n        this._componentFactoryResolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(\n        componentFactory, viewContainerRef.length,\n        portal.injector || viewContainerRef.parentInjector);\n\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n\n    return ref;\n  }\n\n  /**\n   * Attach the given TemplatePortal to this PortlHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n\n    return viewRef;\n  }\n}\n\n\n@NgModule({\n  exports: [CdkPortal, CdkPortalOutlet],\n  declarations: [CdkPortal, CdkPortalOutlet],\n})\nexport class PortalModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n */\nexport class PortalInjector implements Injector {\n  constructor(\n    private _parentInjector: Injector,\n    private _customTokens: WeakMap<any, any>) { }\n\n  get(token: any, notFoundValue?: any): any {\n    const value = this._customTokens.get(token);\n\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n\n    return this._parentInjector.get<any>(token, notFoundValue);\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { WalkthroughElementCoordinate, WalkthroughMargin } from './walkthrough-tools';\n\n@Injectable()\nexport class WalkthroughService {\n\n    private _preventDefault = ((e: Event) => {\n        e = e || window.event;\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n        e.returnValue = false;\n    }).bind(this);\n\n    private _overflowRegex = /(auto|scroll)/;\n\n    private _preventDefaultForScrollKeys = ((e: KeyboardEvent) => {\n        // spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40\n        if (e.keyCode >= 32 && e.keyCode <= 40) {\n            this._preventDefault(e);\n            return false;\n        }\n    }).bind(this);\n\n    retrieveCoordinates(element: HTMLElement, margin?: WalkthroughMargin): WalkthroughElementCoordinate {\n        const clientrect: ClientRect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n\n        const coordinates = {\n            top: clientrect.top - (margin ? margin.top : 0),\n            height: clientrect.height,\n            width: clientrect.width,\n            left: clientrect.left - (margin ? margin.left : 0),\n            margin: {\n                top: parseFloat(style.marginTop),\n                right: parseFloat(style.marginRight),\n                bottom: parseFloat(style.marginBottom),\n                left: parseFloat(style.marginLeft),\n            }\n        };\n        coordinates.top += this.getTop();\n        return coordinates;\n    }\n\n    getTop(): number {\n        return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n    }\n\n    getDocumentHeight() {\n        // Height of entire body : https://stackoverflow.com/a/1147768\n        const body_height = Math.max(\n            document.body.scrollHeight,\n            document.body.offsetHeight,\n            document.documentElement.clientHeight,\n            document.documentElement.scrollHeight,\n            document.documentElement.offsetHeight\n        );\n\n        return Math.max(this.getHeightOfPage() + this.getTop(), body_height);\n    }\n\n    scrollIntoViewIfOutOfView(element: HTMLElement, marginTop = 0) {\n        const topOfPage = this.getTop();\n        const heightOfPage = this.getHeightOfPage();\n        let elementY = 0;\n        let elementH = 0;\n\n        let parent = element;\n        while (parent && parent !== document.body) {\n            elementY += parent.offsetTop;\n            parent = parent.offsetParent as HTMLElement;\n        }\n        elementH = element.offsetHeight;\n\n        if ((topOfPage + heightOfPage) < (elementY + elementH)) {\n            element.scrollIntoView(false);\n        } else if (elementY < topOfPage) {\n            element.scrollIntoView(true);\n            window.scrollBy(0, -30);\n        } else {\n            // test of overflow element\n            let current = element;\n            while (current && current !== document.body) {\n                parent = this.getScrollParent(current);\n                if (current.offsetTop + current.offsetHeight - parent.scrollTop > parent.offsetHeight ||\n                    current.offsetLeft + current.offsetWidth - parent.scrollLeft > parent.offsetWidth) {\n\n                    element.scrollIntoView();\n                    window.scrollBy(0, -30);\n                    break;\n                }\n                current = parent;\n            }\n        }\n    }\n\n    scrollToTopElement(element1: HTMLElement, element2: HTMLElement, margin: WalkthroughMargin) {\n        if (element1 && element2) {\n            const element1Position = this.retrieveCoordinates(element1, margin);\n            const element2Position = this.retrieveCoordinates(element2, margin);\n            const minX = Math.min(element1Position.left, element2Position.left);\n            const minY = Math.min(element1Position.top, element2Position.top);\n            window.scrollTo(minX - 20, minY - 20);\n        }\n    }\n\n    getScrollParent(element: HTMLElement): HTMLElement {\n        let scrollParent;\n        let style = getComputedStyle(element);\n        const excludeStaticParent = style.position === 'absolute';\n\n        if (style.position !== 'fixed') {\n\n            let parent = element.parentElement;\n            while (parent && parent !== document.body) {\n                style = getComputedStyle(parent);\n                if (\n                    !(excludeStaticParent && style.position === 'static') &&\n                    this._overflowRegex.test(style.overflow + style.overflowY + style.overflowX)\n                ) {\n                    scrollParent = parent;\n                    break;\n                }\n                parent = parent.parentElement;\n            }\n        }\n        return scrollParent || document.body;\n    }\n\n    getHeightOfPage() {\n        return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    }\n\n}\n","export class WalkthroughText {\n    previous ?= 'Previous';\n    next ?= 'Next';\n    close ?= 'Close';\n}\n","import {\n    Component,\n    TemplateRef,\n    ViewChild,\n    ElementRef,\n    ViewContainerRef,\n    EmbeddedViewRef,\n    ComponentRef,\n    HostBinding,\n    HostListener,\n    Renderer2\n} from '@angular/core';\nimport { BasePortalHost, ComponentPortal, PortalHostDirective, TemplatePortal } from '@angular/cdk/portal';\n\nimport { WalkthroughElementCoordinate, WalkthroughMargin } from './walkthrough-tools';\nimport { WalkthroughComponent } from './walkthrough.component';\nimport { WalkthroughService } from './walkthrough.service';\nimport { WalkthroughText } from './walkthrough-text';\n\nexport function throwWalkthroughContentAlreadyAttachedError() {\n    throw Error('Attempting to attach walkthrough content after content is already attached');\n}\n\nconst is_safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n@Component({\n    selector: 'walkthrough-container',\n    styles: [\":host { display: block; position: absolute; z-index: 1; top: 0; left: 0; width: 99.9%; min-height: 100%; } :host.hide { display: none; } :host.cursor { cursor: pointer; } :host.backdrop { background-color: rgba(0, 0, 0, 0.6); } button { background: none; border: 0; color: #FFF; } .wkt-zone { position: absolute; } .wkt-zone.hide { display: none; } .wkt-zone.backdrop { box-shadow: 0 0 0 2200px rgba(0, 0, 0, 0.6); } .wkt-zone.glow { box-shadow: 0 0 4px 2px #FFFF66, 0 0 9px 0 #FFFF66, 0 0 36px #FFFF66; } .wkt-zone.clickable { cursor: pointer; } .wkt-zone.highlight { -webkit-animation: highlight .45s 4; animation: highlight .45s 4; } .wkt-container { position: relative; } .wkt-content-block { position: absolute; margin: 1em; padding: 6px; z-index: 1; color: #FFF; min-width: calc(320px - 2em); } .wkt-content-block.hide { display: none; } .wkt-content-block.darken { background-color: rgba(0, 0, 0, 0.6); } .wkt-close + .wkt-content { margin-top: 1.3em; } .wkt-close { position: absolute; right: 1em; cursor: pointer; } .wkt-navigate { display: flex; flex-wrap: wrap; justify-content: center; } .wkt-navigate > button { padding: 6px; font-size: 120%; } .wkt-navigate > button:hover { cursor: pointer; text-decoration: underline; } .wkt-previous-link::before { content: '<< '; } .wkt-next-link::after { content: ' >>'; } div.hide { display: none; } svg { overflow: visible; position: absolute; top: -1px; left: -1px; border: 1px solid transparent; } #wkt-arrow > path { stroke-width: 0; } .wkt-arrow-path { stroke-width: 2px; fill: none; } @-webkit-keyframes highlight { 0% { background-color: none; } 50% { background-color: rgba(255, 255, 255, 0.8); } 100% { background-color: none; } } @keyframes highlight { 0% { background-color: none; } 50% { background-color: rgba(255, 255, 255, 0.8); } 100% { background-color: none; } } @media screen and (min-width: 1920px), screen and (min-height: 1920px) { .wkt-zone.backdrop { box-shadow: 0 0 0 4400px rgba(0, 0, 0, 0.6); } } @media screen and (min-width: 3840px), screen and (min-height: 3840px) { .wkt-zone.backdrop { box-shadow: 0 0 0 8800px rgba(0, 0, 0, 0.6); } } _:default:not(:root:root), .wkt-zone.backdrop { box-shadow: 0 0 0 2000px rgba(0, 0, 0, 0.6) !important; } \"],\n    template: \"<div class=\\\"wkt-container\\\"> <div class=\\\"wkt-zone\\\" #zone (click)=\\\"clickZone($event)\\\" [class.hide]=\\\"!hasHighlightZone\\\" [class.backdrop]=\\\"hasBackdrop\\\" [class.glow]=\\\"hasGlow\\\" [class.clickable]=\\\"hasClickable\\\" [class.highlight]=\\\"hasHighlight\\\" [style.padding]=\\\"marginZone\\\"></div> <div class=\\\"wkt-content-block\\\" [class.hide]=\\\"hideOther\\\" [class.darken]=\\\"contentStyle === 'draken'\\\" #contentBlock> <button type=\\\"button\\\" class=\\\"wkt-close\\\" *ngIf=\\\"hasCloseButton\\\" (click)=\\\"close()\\\">✖</button> <div class=\\\"wkt-content\\\"> <p *ngIf=\\\"contentText\\\">{{contentText}}</p> <ng-template cdkPortalHost></ng-template> </div> <div class=\\\"wkt-navigate\\\" *ngIf=\\\"hasPrevious||hasNext||hasFinish\\\"> <button type=\\\"button\\\" class=\\\"wkt-previous-link\\\" *ngIf=\\\"hasPrevious\\\" (click)=\\\"previous()\\\">{{text.previous}}</button> <button type=\\\"button\\\" class=\\\"wkt-next-link\\\" *ngIf=\\\"hasNext\\\" (click)=\\\"next()\\\">{{text.next}}</button> <button type=\\\"button\\\" class=\\\"wkt-finish-link\\\" *ngIf=\\\"hasFinish\\\" (click)=\\\"close(true)\\\">{{text.close}}</button> </div> </div> <div *ngIf=\\\"hasArrow\\\" [class.hide]=\\\"hideOther\\\"> <svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"100%\\\" height=\\\"100%\\\"> <defs> <marker id=\\\"wkt-arrow\\\" viewBox=\\\"0 0 10 10\\\" refX=\\\"8\\\" refY=\\\"5\\\" markerUnits=\\\"strokeWidth\\\" orient=\\\"auto\\\" markerWidth=\\\"10\\\" markerHeight=\\\"10\\\"> <polyline points=\\\"0,0 10,5 0,10 5,5\\\" stroke-width=\\\"0\\\" [attr.fill]=\\\"arrowColor || '#FFF'\\\" /> </marker> </defs> <path class=\\\"wkt-arrow-path\\\" [attr.d]=\\\"arrowPath\\\" [attr.stroke]=\\\"arrowColor || '#FFF'\\\" [attr.marker-end]=\\\"markerUrl\\\" /> </svg> </div> </div>\"\n})\nexport class WalkthroughContainerComponent extends BasePortalHost {\n\n    markerUrl = 'url(#wkt-arrow)';\n\n    show = false;\n    pause = false;\n    parent: WalkthroughComponent;\n\n    // highlight zone\n\n    hasHighlightZone = false;\n    hasHighlight = false;\n    hasBackdrop = false;\n    hasGlow = false;\n    hasClickable: boolean;\n    hideOther: boolean;\n\n    // navigate\n\n    hasPrevious = false;\n    hasNext = false;\n    hasFinish = false;\n    hasCloseButton = false;\n    hasCloseAnywhere = true;\n\n    // arrow\n\n    hasArrow = false;\n    arrowPath: string;\n    arrowMarkerDist = 7;\n\n    // styling\n\n    contentStyle: string;\n    radius: string;\n    arrowColor: string;\n    marginZone: string | null;\n    marginZonePx = new WalkthroughMargin();\n\n    // content\n\n    contentText: string;\n\n    // texts change / i18n\n\n    text = new WalkthroughText();\n\n    // elements\n\n    @ViewChild(PortalHostDirective) _portalHost: PortalHostDirective;\n    @ViewChild('content') content: TemplateRef<any>;\n    @ViewChild('contentBlock') contentBlock: ElementRef;\n    @ViewChild('zone') zone: ElementRef;\n\n    // HostBinding\n\n    @HostBinding('attr.id')\n    get id() {\n        return this.parent ? this.parent.id + '-container' : null;\n    }\n\n    @HostBinding('class.hide')\n    get hide() {\n        return !this.show;\n    }\n\n    @HostBinding('class.cursor')\n    get cursor() {\n        return this.hasCloseAnywhere;\n    }\n\n    @HostBinding('class.backdrop')\n    get backdrop() {\n        return !this.hasHighlightZone && this.hasBackdrop;\n    }\n\n    private _contentPosition: 'above' | 'top' | 'center' | 'bottom' | 'below';\n    private _arrowPosition: 'topBottom' | 'leftRight';\n\n    constructor(\n        public viewContainerRef: ViewContainerRef,\n        private _walkthroughService: WalkthroughService,\n        private _renderer: Renderer2,\n        private _el: ElementRef\n    ) {\n        super();\n    }\n\n    @HostListener('click')\n    click() {\n        if (this.hasCloseAnywhere && this.show) {\n            this.close();\n        }\n    }\n\n    clickZone(event: Event) {\n        if (this.parent && this.hasClickable) {\n            this.parent.focusClick(event, this);\n        }\n    }\n\n    /**\n     * Attach a ComponentPortal as content to this walkthrough container.\n     * @param portal Portal to be attached as the walkthrough content.\n     */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n        if (this._portalHost.hasAttached()) {\n            throwWalkthroughContentAlreadyAttachedError();\n        }\n\n        // this._savePreviouslyFocusedElement();\n        return this._portalHost.attachComponentPortal(portal);\n    }\n\n    /**\n     * Attach a TemplatePortal as content to this walkthrough container.\n     * @param portal Portal to be attached as the walkthrough content.\n     */\n    attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n        if (this._portalHost.hasAttached()) {\n            throwWalkthroughContentAlreadyAttachedError();\n        }\n\n        // this._savePreviouslyFocusedElement();\n        return this._portalHost.attachTemplatePortal(portal);\n    }\n\n    setHeight(): void {\n        this._renderer.setStyle(this._el.nativeElement, 'height', this._walkthroughService.getDocumentHeight() + 'px');\n    }\n\n    hightlightZone(\n        coordinate: WalkthroughElementCoordinate,\n        scrollDiff: number,\n        animation: 'none' | 'linear',\n        animationDelays: number,\n        continueFunction: () => {}\n    ) {\n\n        const element = (this.zone.nativeElement as HTMLElement);\n        const zoneStyle = element.style;\n        const style = window.getComputedStyle(element, null);\n\n        if (animation === 'linear' && animationDelays > 0 && style.left !== 'auto') {\n            this.hideOther = true;\n            const fragment = 20;\n            const intervale = animationDelays / fragment;\n            const left = parseInt(style.left, 10);\n            const top = scrollDiff + parseInt(style.top, 10);\n            const width = parseInt(style.width, 10);\n            const height = parseInt(style.height, 10);\n            const partLeft = (coordinate.left - left) / fragment;\n            const partTop = (coordinate.top - top) / fragment;\n            const partWidth = (coordinate.width - width) / fragment;\n            const partHeight = (coordinate.height - height) / fragment;\n            let count = 0;\n\n            this.show = true;\n            zoneStyle.borderRadius = '50%';\n            const timer = setInterval(() => {\n\n                zoneStyle.left = (left + partLeft * count) + 'px';\n                zoneStyle.top = (top + partTop * count) + 'px';\n                zoneStyle.width = (width + partWidth * count) + 'px';\n                zoneStyle.height = (height + partHeight * count) + 'px';\n                if (count++ >= fragment) {\n                    clearInterval(timer);\n                    this.hideOther = false;\n                    continueFunction();\n                }\n            }, intervale);\n\n        } else {\n            zoneStyle.left = coordinate.left + 'px';\n            zoneStyle.top = coordinate.top + 'px';\n            zoneStyle.width = coordinate.width + 'px';\n            zoneStyle.height = coordinate.height + 'px';\n\n            continueFunction();\n        }\n    }\n\n    hightlightZoneStyling(element: HTMLElement) {\n        if (element) {\n            const zoneStyle = (this.zone.nativeElement as HTMLElement).style;\n            if (this.radius) {\n                if (Number(this.radius) === parseFloat(this.radius)) {\n                    // if is numeric, change in %\n                    zoneStyle.borderRadius = this.radius + '%';\n                } else if (this.radius === 'auto') {\n                    // if mode auto\n                    const elementStyle = window.getComputedStyle(element, null);\n                    // borderRadius work only on Chrome, use TopLeft, TopRight... for Firefox/Egde/IE\n                    zoneStyle.borderTopLeftRadius = elementStyle.borderTopLeftRadius;\n                    zoneStyle.borderTopRightRadius = elementStyle.borderTopRightRadius;\n                    zoneStyle.borderBottomLeftRadius = elementStyle.borderBottomLeftRadius;\n                    zoneStyle.borderBottomRightRadius = elementStyle.borderBottomRightRadius;\n                } else {\n                    // if is numeric, change in %\n                    zoneStyle.borderRadius = this.radius;\n                }\n            } else {\n                zoneStyle.borderRadius = '';\n            }\n        }\n    }\n\n    contentBlockPosition(\n        coordinate: WalkthroughElementCoordinate,\n        alignContent: 'left' | 'center' | 'right',\n        verticalAlignContent: 'above' | 'top' | 'center' | 'bottom' | 'below',\n        contentSpacing: number,\n        verticalContentSpacing: number) {\n        const element = this.contentBlock.nativeElement as HTMLElement;\n\n        const elementSize = this._walkthroughService.retrieveCoordinates(element);\n        const width = elementSize.width + elementSize.margin.left + elementSize.margin.right;\n        const height = elementSize.height + elementSize.margin.top + elementSize.margin.bottom;\n\n        // check if we've got the space to respect the alignContent attribute\n        let notEnoughSpace = false;\n        if (this.hasHighlightZone) {\n            const spaceLeft = coordinate.left;\n            const spaceRight = window.innerWidth - coordinate.left - coordinate.width;\n            if (spaceLeft < width && spaceRight < width) {\n                notEnoughSpace = true;\n            }\n            // if not enough space to respect the alignContent, content goes above/below\n            if ((verticalAlignContent === 'top' ||\n                verticalAlignContent === 'center' ||\n                verticalAlignContent === 'bottom') && !notEnoughSpace) {\n\n                // change align center to left or right if not enough space to align center\n                if (alignContent === 'center') {\n                    const maxSpace = Math.max(spaceRight, spaceLeft);\n                    if (maxSpace < width + ((window.innerWidth - width) / 2)) {\n                        alignContent = spaceRight > spaceLeft ? 'right' : 'left';\n                    }\n                } else if (alignContent === 'left' && spaceLeft < width ||\n                    alignContent === 'right' && spaceRight < width) {\n                    verticalAlignContent = verticalAlignContent === 'bottom' || coordinate.top < height ? 'below' : 'above';\n                }\n            }\n        }\n\n        // if not enough space on screen width, we center the content\n        if (notEnoughSpace) {\n            alignContent = 'center';\n        }\n\n        // position of content left/center/right\n        element.style.right = '';\n        element.style.left = '';\n        if (alignContent === 'left') {\n            element.style.left = '0';\n            if (this.hasHighlightZone) {\n                const space = coordinate.left - width;\n                // handle contentSpacing\n                if (contentSpacing && space > contentSpacing) {\n                    element.style.left = (\n                        coordinate.left -\n                        width -\n                        contentSpacing\n                    ) + 'px';\n                }\n            }\n        } else if (alignContent === 'center') {\n            element.style.left = (window.innerWidth / 2 - width / 2) + 'px';\n        } else if (alignContent === 'right') {\n            element.style.right = '0';\n            if (this.hasHighlightZone) {\n                const space = window.innerWidth - coordinate.left - coordinate.width - width;\n                // handle contentSpacing\n                if (contentSpacing && space > contentSpacing) {\n                    element.style.right = '';\n                    element.style.left = (\n                        coordinate.left +\n                        coordinate.width +\n                        contentSpacing\n                    ) + 'px';\n                }\n            }\n        }\n\n        if (this.hasHighlightZone) {\n            // for arrow position\n            const startLeft = this._walkthroughService.retrieveCoordinates(element).left + width / 2;\n\n            this._arrowPosition = startLeft > (coordinate.left - WalkthroughComponent.minimalMargin)\n                && startLeft < (coordinate.left + coordinate.width + WalkthroughComponent.minimalMargin)\n                ? 'topBottom' : 'leftRight';\n\n            // if there is enough place on the left or on the right, we consider verticalAlignContent, otherwise, we ignore it\n            if (verticalAlignContent && !notEnoughSpace) {\n                let space = 0;\n                this._contentPosition = verticalAlignContent;\n                switch (verticalAlignContent) {\n                    case 'above':\n                        space = coordinate.top;\n                        if (space > verticalContentSpacing) {\n                            element.style.top = (coordinate.top - height - verticalContentSpacing) + 'px';\n                        } else {\n                            element.style.top = '0';\n                        }\n                        this._arrowPosition = 'topBottom';\n                        break;\n                    case 'top':\n                        element.style.top = (coordinate.top) + 'px';\n                        break;\n                    case 'center':\n                        element.style.top = (coordinate.top + (coordinate.height / 2) - (height / 2)) + 'px';\n                        break;\n                    case 'bottom':\n                        element.style.top = (coordinate.top + coordinate.height - height) + 'px';\n                        break;\n                    case 'below':\n                        space = this._walkthroughService.getDocumentHeight() - coordinate.top + coordinate.height;\n                        if (space > verticalContentSpacing) {\n                            element.style.top = (coordinate.top + coordinate.height + verticalContentSpacing) + 'px';\n                        } else {\n                            element.style.top = (this._walkthroughService.getDocumentHeight() - height) + 'px';\n                        }\n                        this._arrowPosition = 'topBottom';\n                        break;\n                }\n            } else {\n                // position of content top/bottom\n                if (verticalAlignContent === 'below' || coordinate.top < height) {\n                    element.style.top = (coordinate.top + coordinate.height + WalkthroughComponent.minimalMargin) + 'px';\n                    this._contentPosition = 'below';\n                } else {\n                    element.style.top = (coordinate.top - height - WalkthroughComponent.minimalMargin) + 'px';\n                    this._contentPosition = 'above';\n                }\n            }\n        } else {\n            element.style.top = (this._walkthroughService.getHeightOfPage() / 2 - height / 2) + 'px';\n        }\n\n    }\n\n    arrowPosition(coordinate: WalkthroughElementCoordinate, verticalContentSpacing: number) {\n\n        const contentBlockElement = this.contentBlock.nativeElement as HTMLElement;\n        const contentBlockCoordinates = this._walkthroughService.retrieveCoordinates(contentBlockElement);\n\n        let startLeft = contentBlockCoordinates.left + contentBlockCoordinates.width / 2;\n        let startTop = contentBlockCoordinates.top + contentBlockCoordinates.height;\n        let centerTop: number;\n        let centerLeft: number;\n        let endLeft = coordinate.left;\n        let endTop = coordinate.top + this.marginZonePx.top;\n\n        switch (this._contentPosition) {\n            case 'top':\n            case 'center':\n            case 'bottom':\n                if (contentBlockCoordinates.left > coordinate.left) {\n                    startLeft = contentBlockCoordinates.left;\n                } else {\n                    startLeft = contentBlockCoordinates.left + contentBlockCoordinates.width;\n                }\n                startTop -= contentBlockCoordinates.height / 2;\n                break;\n            case 'below':\n                startTop -= contentBlockCoordinates.height;\n                break;\n        }\n\n        if (this._arrowPosition === 'topBottom') {\n            endLeft += coordinate.width / 2;\n\n            if (this._contentPosition === 'below') {\n                endTop += coordinate.height + 6;\n            } else {\n                endTop -= 6;\n            }\n\n            centerLeft = (startLeft + endLeft) / 2;\n            centerTop = (startTop + endTop) / 2;\n\n            this.arrowPath = `M${startLeft},${startTop} Q${startLeft},${centerTop} ${centerLeft},${centerTop} `\n                + `Q${endLeft},${centerTop} ${endLeft},${endTop}`;\n\n        } else {\n            if (startLeft > coordinate.left) {\n                endLeft += coordinate.width + this.arrowMarkerDist;\n            } else {\n                endLeft -= this.arrowMarkerDist;\n            }\n\n            endTop += coordinate.height / 2;\n\n            centerLeft = (startLeft + endLeft) / 2;\n            centerTop = (startTop + endTop) / 2;\n\n            let directStartLeft: number = startLeft;\n            let directStartTop: number = startTop;\n            if (this._contentPosition === 'top' || this._contentPosition === 'bottom') {\n                directStartLeft = contentBlockCoordinates.left + (contentBlockCoordinates.width / 2);\n                directStartTop = (this._contentPosition === 'top') ?\n                    (contentBlockCoordinates.top + contentBlockCoordinates.height) :\n                    (contentBlockCoordinates.top);\n\n                // we use direct curve only if the arrow don't cross the content, otherwise, we use double curved\n                if (\n                    (this._contentPosition === 'top' && directStartTop < (endTop - WalkthroughComponent.minimalMargin)) ||\n                    (this._contentPosition === 'bottom' && directStartTop > (endTop + WalkthroughComponent.minimalMargin))\n                ) {\n                    this.arrowPath = `M${directStartLeft},${directStartTop} Q${directStartLeft},${endTop} ${endLeft},${endTop}`;\n                } else {\n                    this.arrowPath = `M${startLeft},${startTop} Q${centerLeft},${startTop} ${centerLeft},${centerTop} `\n                        + `Q${centerLeft},${endTop} ${endLeft},${endTop}`;\n                }\n            } else {\n                this.arrowPath = `M${directStartLeft},${directStartTop} Q${directStartLeft},${endTop} ${endLeft},${endTop}`;\n            }\n        }\n    }\n\n    /**\n     * stop the walkthrough : hide the container and change to pause at true\n     */\n    stop() {\n        if (this.parent && !this.pause && this.show) {\n            this.show = false;\n            this.pause = true;\n        }\n    }\n\n    /**\n     * continue the walkthrough if is stopped : show the container and change to pause at false\n     */\n    continue(unpause = false) {\n        if (this.parent && this.pause) {\n            this.show = true;\n            this.pause = false;\n            if (unpause) {\n                // if focusElement does not exist anymore, we close the walkthrough (without emiting any event)\n                if (this.parent.focusElementSelector && !document.querySelector(this.parent.focusElementSelector)) {\n                    this.close(false, false);\n                } else {\n                    // we update elements positioning on the current walkthrough\n                    this.parent.refresh();\n                }\n            }\n        }\n    }\n\n    open() {\n        // change markerUrl on Safari\n        // related to\n        // https://gist.github.com/leonderijke/c5cf7c5b2e424c0061d2\n        // http://stackoverflow.com/a/18265336/796152\n        // http://www.w3.org/TR/SVG/linking.html\n        if (is_safari) {\n            this.markerUrl = 'url(' + window.location.href + '#wkt-arrow)';\n        }\n        this.show = true;\n    }\n\n    previous() {\n        this.close(false, false);\n\n        // we check if previous walkthrough is not disabled\n        let current = this.parent;\n        while (current) {\n            if (current.previousStep && !current.previousStep.disabled) {\n                current.loadPrevioustStep();\n                return;\n            } else {\n                if (!current.previousStep) {\n                    break;\n                }\n                current = current.previousStep;\n            }\n        }\n        // no more previous walkthrough enabled, we quit the walkthrough\n        this.parent = current;\n        this.close(true, true);\n    }\n\n    next() {\n        this.close(false, false);\n\n        // we check if next walkthrough is not disabled\n        let current = this.parent;\n        while (current) {\n            if (current.nextStep && !current.nextStep.disabled) {\n                current.loadNextStep();\n                return;\n            } else {\n                if (!current.nextStep) {\n                    break;\n                }\n                current = current.nextStep;\n            }\n        }\n        // no more next walkthrough enabled, we quit the walkthrough\n        this.parent = current;\n        this.close(true, true);\n    }\n\n    close(finishLink = false, closeWalkthrough = true) {\n        // remove content\n        this._portalHost.dispose();\n        // hide\n        this.show = false;\n        if (this.parent) {\n            this.parent.hide(finishLink, closeWalkthrough);\n        }\n    }\n\n}\n","import {\n    Type,\n    TemplateRef,\n    Input,\n    Output,\n    Component,\n    ComponentFactoryResolver,\n    EmbeddedViewRef,\n    ComponentRef,\n    ApplicationRef,\n    Injector,\n    HostListener,\n    OnInit,\n    AfterViewInit,\n    Renderer2,\n    EventEmitter\n} from '@angular/core';\n\nimport { ComponentPortal, ComponentType, PortalInjector, TemplatePortal } from '@angular/cdk/portal';\nimport { WalkthroughContainerComponent } from './walkthrough-container.component';\nimport { WalkthroughService } from './walkthrough.service';\nimport { WalkthroughText } from './walkthrough-text';\nimport { WalkthroughEvent, booleanValue, WalkthroughElementCoordinate, WalkthroughMargin } from './walkthrough-tools';\n\nlet nextUniqueId = 0;\n\n@Component({\n    selector: 'ng-walkthrough',\n    template: ''\n})\nexport class WalkthroughComponent implements AfterViewInit {\n\n    private static _walkthroughContainer: ComponentRef<WalkthroughContainerComponent> = null;\n    private static _walkthroughContainerCreating = false;\n    public static minimalMargin = 30;\n\n    @Output() closed: EventEmitter<boolean> = new EventEmitter();\n    @Output() finished: EventEmitter<WalkthroughEvent> = new EventEmitter();\n    @Output() ready: EventEmitter<WalkthroughEvent> = new EventEmitter();\n\n    @Input() focusElementCSSClass: string;\n    @Input() rootElement: string;\n\n    @Input() focusElementSelector: string;\n    @Input() typeSelector: 'element' | 'zone' = 'element';\n    @Input() focusClick: (event: Event, content: WalkthroughContainerComponent) => {};\n    @Input() radius: string;\n\n    @Input() previousStep: WalkthroughComponent;\n    @Input() nextStep: WalkthroughComponent;\n    @Input() texts: WalkthroughText;\n\n    @Input() contentTemplate: TemplateRef<any>;\n    @Input() contentText: string;\n    @Input() contentStyle: 'none' | 'draken' = 'draken';\n\n    @Input()\n    get marginZone() { return this._marginZone; }\n    set marginZone(points: string | null) {\n        if (this._marginZone !== points) {\n            if (points === null) {\n                this._marginZone = null;\n            }\n\n            this._marginZonePx = WalkthroughMargin.parsePoints(points);\n            if (this._marginZonePx !== null) {\n                this._marginZone = points;\n            }\n        }\n    }\n\n    @Input()\n    get arrowColor() { return this._arrowColor; }\n    set arrowColor(color: string) {\n        if (this._arrowColor !== color) {\n            this._arrowColor = color;\n            if (this._getInstance()) {\n                this._getInstance().arrowColor = this._arrowColor;\n            }\n        }\n    }\n\n    @Input() animation: 'none' | 'linear' = 'none';\n    @Input() animationDelays = 0;\n\n    @Input()\n    get id() { return this._id; }\n    set id(value: string) { this._id = value || this._uid; }\n\n    @Input()\n    get alignContent() {\n        return this._alignContent;\n    }\n    set alignContent(value: 'left' | 'center' | 'right') {\n        if (this._alignContent !== value) {\n            this._alignContent = value;\n            this._updateElementPositions(this._getInstance());\n\n        } else {\n            this._alignContent = value;\n        }\n    }\n\n    @Input()\n    get verticalAlignContent() {\n        return this._verticalAlignContent;\n    }\n    set verticalAlignContent(value: 'above' | 'top' | 'center' | 'bottom' | 'below') {\n        if (this._verticalAlignContent !== value) {\n            this._verticalAlignContent = value;\n            this._updateElementPositions(this._getInstance());\n        } else {\n            this._verticalAlignContent = value;\n        }\n    }\n\n    @Input()\n    get contentSpacing() {\n        return this._contentSpacing;\n    }\n    set contentSpacing(value: number) {\n        value = Math.max(WalkthroughComponent.minimalMargin, value);\n        if (this._contentSpacing !== value) {\n            this._contentSpacing = value * 1;\n            this._updateElementPositions(this._getInstance());\n        } else {\n            this._contentSpacing = value * 1;\n        }\n    }\n\n    @Input()\n    get verticalContentSpacing() {\n        return this._verticalContentSpacing;\n    }\n    set verticalContentSpacing(value: number) {\n        value = Math.max(WalkthroughComponent.minimalMargin, value);\n        if (this._verticalContentSpacing !== value) {\n            this._verticalContentSpacing = value * 1;\n            this._updateElementPositions(this._getInstance());\n        } else {\n            this._verticalContentSpacing = value * 1;\n        }\n    }\n\n    @Input()\n    get closeButton() {\n        return this._hasCloseButton;\n    }\n    set closeButton(value: string | boolean) {\n        this._hasCloseButton = booleanValue(value);\n    }\n\n    @Input()\n    get closeAnywhere() {\n        return this._hasCloseAnywhere;\n    }\n    set closeAnywhere(value: string | boolean) {\n        this._hasCloseAnywhere = booleanValue(value);\n    }\n\n    @Input()\n    get showArrow() {\n        return this._hasArrow;\n    }\n    set showArrow(value: string | boolean) {\n        this._hasArrow = booleanValue(value);\n    }\n\n    @Input()\n    get finishButton() {\n        return this._hasFinish;\n    }\n    set finishButton(value: string | boolean) {\n        this._hasFinish = booleanValue(value);\n    }\n\n    @Input()\n    get focusHighlightAnimation() {\n        return this._hasHighlightAnimation;\n    }\n    set focusHighlightAnimation(value: string | boolean) {\n        this._hasHighlightAnimation = booleanValue(value);\n    }\n\n    @Input()\n    get focusBackdrop() {\n        return this._hasBackdrop;\n    }\n    set focusBackdrop(value: string | boolean) {\n        this._hasBackdrop = booleanValue(value);\n    }\n\n    @Input()\n    get focusGlow() {\n        return this._hasGlow;\n    }\n    set focusGlow(value: string | boolean) {\n        this._hasGlow = booleanValue(value);\n    }\n\n    @Input()\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value: boolean) {\n        this._disabled = value;\n\n        const instance = this._getInstance();\n        if (instance) {\n            setTimeout(() => {\n                instance.hasPrevious = this._hasPreviousStep(instance);\n                instance.hasNext = this._hasNextStep(instance);\n                if (!instance.hasNext) {\n                    instance.hasFinish = true;\n                } else {\n                    instance.hasFinish = <boolean>instance.parent.finishButton;\n                }\n            }, 50);\n        }\n    }\n\n    private _id: string;\n    private _uid = `walkthrough-${nextUniqueId++}`;\n    private _readyHasBeenEmited = false;\n    private _display = false;\n    private _hasHighlightAnimation = false;\n    private _hasBackdrop = false;\n    private _hasGlow = false;\n    private _hasFinish = false;\n    private _hasArrow = false;\n    private _hasCloseButton = false;\n    private _hasCloseAnywhere = true;\n    private _disabled = false;\n    private _arrowColor: string;\n    private _marginZone: string;\n    private _marginZonePx = new WalkthroughMargin();\n    private _alignContent: 'left' | 'center' | 'right' = 'left';\n    private _verticalAlignContent: 'above' | 'top' | 'center' | 'bottom' | 'below' = 'top';\n    private _contentSpacing = 0;\n    private _verticalContentSpacing = 50;\n    private _focusElement: HTMLElement;\n    private _focusElementEnd: HTMLElement;\n    private _offsetCoordinates: WalkthroughElementCoordinate;\n    private _windowWidth: number;\n\n    static walkthroughStop() {\n        if (WalkthroughComponent._walkthroughContainer) {\n            WalkthroughComponent._walkthroughContainer.instance.stop();\n        }\n    }\n\n    static walkthroughHasShow(): boolean {\n        return WalkthroughComponent._walkthroughContainer\n            ? WalkthroughComponent._walkthroughContainer.instance.show\n            : false;\n    }\n\n    static walkthroughHasPause(): boolean {\n        return WalkthroughComponent._walkthroughContainer\n            ? WalkthroughComponent._walkthroughContainer.instance.pause\n            : false;\n    }\n\n    static walkthroughContinue() {\n        if (WalkthroughComponent._walkthroughContainer) {\n            WalkthroughComponent._walkthroughContainer.instance.continue(true);\n        }\n    }\n\n    static walkthroughNext() {\n        if (WalkthroughComponent._walkthroughContainer) {\n            WalkthroughComponent._walkthroughContainer.instance.next();\n        }\n    }\n\n    static walkthroughPrevious() {\n        if (WalkthroughComponent._walkthroughContainer) {\n            WalkthroughComponent._walkthroughContainer.instance.previous();\n        }\n    }\n\n    constructor(\n        private _componentFactoryResolver: ComponentFactoryResolver,\n        private _applicationRef: ApplicationRef,\n        private _injector: Injector,\n        private _renderer: Renderer2,\n        private _walkthroughService: WalkthroughService\n    ) { }\n\n    @HostListener('window:resize')\n    resize() {\n        if (this._display &&\n            WalkthroughComponent._walkthroughContainer &&\n            window.innerWidth !== this._windowWidth &&\n            !WalkthroughComponent.walkthroughHasPause()) {\n            this._elementLocations();\n        }\n    }\n\n    ngAfterViewInit() {\n        // init the Walkthrough element container\n        if (!WalkthroughComponent._walkthroughContainer && !WalkthroughComponent._walkthroughContainerCreating) {\n            WalkthroughComponent._walkthroughContainerCreating = true;\n            setTimeout(() => {\n                WalkthroughComponent._walkthroughContainer =\n                    this._appendComponentToBody<WalkthroughContainerComponent>(WalkthroughContainerComponent);\n            }, 0);\n        }\n    }\n\n    next(\n        closedEvent: EventEmitter<boolean> = undefined,\n        finishedEvent: EventEmitter<WalkthroughEvent> = undefined\n    ) {\n        if (closedEvent) {\n            this.closed = closedEvent;\n        }\n        if (finishedEvent) {\n            this.finished = finishedEvent;\n        }\n        this.open();\n    }\n\n    refresh() {\n        if (!this._getInstance().pause) {\n            this._elementLocations();\n        }\n    }\n\n    open() {\n        if (!this._getInstance().pause) {\n            this._elementLocations();\n        } else {\n            console.warn('Another walkthrough is in pause. Please close it before.');\n        }\n    }\n\n    /**\n     * Do not use this method outside of the library\n     */\n    loadPrevioustStep() {\n        setTimeout(() => {\n            this.previousStep._next(this.closed, this.finished);\n        }, 0);\n    }\n\n    /**\n     * Do not use this method outside of the library\n     */\n    loadNextStep() {\n        setTimeout(() => {\n            this.nextStep._next(this.closed, this.finished);\n        }, 0);\n    }\n\n    /**\n     * Do not use this method outside of the library\n     */\n    hide(finishLink = false, closeWalkthrough = true) {\n        this._display = false;\n\n        // add CSS to focusElement\n        if (this.focusElementCSSClass) {\n            this._renderer.removeClass(this._focusElement, this.focusElementCSSClass);\n        }\n\n        if (closeWalkthrough) {\n            setTimeout(() => {\n                // emit closed event\n                this.closed.emit(finishLink);\n                if (!this.nextStep) {\n                    // emit finished event\n                    this.finished.emit(new WalkthroughEvent(this, this._focusElement));\n                }\n            }, 20);\n        }\n    }\n\n    private _show() {\n        this._display = true;\n    }\n\n    private _next(\n        closedEvent: EventEmitter<boolean> = undefined,\n        finishedEvent: EventEmitter<WalkthroughEvent> = undefined\n    ) {\n        if (closedEvent) {\n            this.closed = closedEvent;\n        }\n        if (finishedEvent) {\n            this.finished = finishedEvent;\n        }\n        this.open();\n    }\n\n    private _getInstance(): WalkthroughContainerComponent {\n        return WalkthroughComponent._walkthroughContainer\n            ? WalkthroughComponent._walkthroughContainer.instance\n            : null;\n    }\n\n    private _appendComponentToBody<T>(component: Type<T>): ComponentRef<T> {\n        // create a component reference\n        const componentRef = this._componentFactoryResolver.resolveComponentFactory(component).create(this._injector);\n\n        // attach component to the appRef so that so that it will be dirty checked.\n        this._applicationRef.attachView(componentRef.hostView);\n\n        // get DOM element from component\n        const domElem = (componentRef.hostView as EmbeddedViewRef<T>).rootNodes[0] as HTMLElement;\n\n        document.body.appendChild(domElem);\n\n        return componentRef;\n    }\n\n    private _attachWalkthroughContent<T>(\n        componentOrTemplateRef: ComponentType<T> | TemplateRef<T>,\n        walkthroughContainer: WalkthroughContainerComponent\n    ) {\n        if (componentOrTemplateRef instanceof TemplateRef) {\n            walkthroughContainer.attachTemplatePortal(\n                new TemplatePortal<T>(componentOrTemplateRef, null!));\n        } else {\n            const injectionTokens = new WeakMap();\n            injectionTokens.set(WalkthroughContainerComponent, walkthroughContainer);\n            const injector = new PortalInjector(this._injector, injectionTokens);\n            walkthroughContainer.attachComponentPortal(\n                new ComponentPortal(componentOrTemplateRef, undefined, injector)\n            );\n\n        }\n\n    }\n\n    private _elementLocations(): void {\n\n        this._getFocusElement();\n\n        const element = this._focusElement;\n        if (element) {\n            this._walkthroughService.scrollIntoViewIfOutOfView(element);\n\n            // if there is a root element defined (in some cases when position fixed is used, we need to scroll on it)\n            if (this.rootElement) {\n                document.querySelector(this.rootElement).scrollIntoView(true);\n            }\n\n            this._offsetCoordinates = this._walkthroughService.retrieveCoordinates(element, this._marginZonePx);\n\n            if (this.typeSelector === 'zone') {\n                const offsetEndCoordinatesEnd = this._walkthroughService.retrieveCoordinates(\n                    this._focusElementEnd,\n                    this._marginZonePx\n                );\n\n                this._offsetCoordinates.height = offsetEndCoordinatesEnd.top\n                    - this._offsetCoordinates.top\n                    + offsetEndCoordinatesEnd.height;\n                this._offsetCoordinates.width = offsetEndCoordinatesEnd.left\n                    - this._offsetCoordinates.left\n                    + offsetEndCoordinatesEnd.width;\n            }\n        } else {\n            this._offsetCoordinates = null;\n        }\n        this._setFocus();\n        this._windowWidth = window.innerWidth;\n    }\n\n    /**\n     *\n     */\n    private _getFocusElement() {\n        let focusElements: NodeListOf<HTMLElement>;\n        try {\n            focusElements = this.focusElementSelector\n                ? document.querySelectorAll(this.focusElementSelector) as NodeListOf<HTMLElement>\n                : null;\n        } catch (error) {\n            console.error(\n                `#${this.id}@focusElementSelector: '${this.focusElementSelector}' is not a valid selector.\\n`,\n                error\n            );\n        }\n\n        // getting focus element\n\n        if (focusElements && focusElements.length > 0) {\n            if (focusElements.length > 1) {\n                // Multiple items fit selector, displaying first visible as focus item in 'element' mode\n\n                const l = focusElements.length;\n                for (let i = 0; i < l; i++) {\n                    // offsetHeight not of 0 means visible\n                    if (focusElements[i].offsetHeight) {\n                        this._focusElement = focusElements[i];\n                        i = focusElements.length;\n                        break;\n                    }\n                }\n\n                // if typeSelector is by zone, get also the last element\n                if (this.typeSelector === 'zone') {\n\n                    for (let i = l - 1; i >= 0; i--) {\n                        // offsetHeight not of 0 means visible\n                        if (focusElements[i].offsetHeight) {\n                            this._focusElementEnd = focusElements[i];\n                            i = focusElements.length;\n                            break;\n                        }\n                    }\n\n                    // this the zone this just a unique element, change mode for 'element'\n                    if (this._focusElement === this._focusElementEnd) {\n                        this.typeSelector = 'element';\n                    }\n                }\n\n            } else {\n                this._focusElement = focusElements[0];\n                this.typeSelector = 'element';\n            }\n        } else {\n            this._focusElement = null;\n        }\n    }\n\n    /**\n     * get instance, hightlight the focused element et show the template\n     */\n    private _setFocus() {\n        const instance = this._getInstance();\n        if (instance) {\n            const scrollY = window.pageXOffset;\n            this._initStylingTemplate(instance);\n            setTimeout(() => {\n                if (this._focusElement && instance.zone) {\n                    instance.hightlightZone(\n                        this._offsetCoordinates,\n                        scrollY - window.pageXOffset,\n                        this.animation,\n                        this.animationDelays,\n                        this._setFocusContinue.bind(this)\n                    );\n                } else {\n                    this._setFocusContinue();\n                }\n            }, 20);\n        }\n    }\n\n    private _setFocusContinue() {\n        const instance = this._getInstance();\n        if (!this._display) {\n            this._attachContentTemplate();\n\n            this._initContentTemplate(instance);\n        }\n        setTimeout(() => {\n            instance.hightlightZoneStyling(this._focusElement);\n            this._updateElementPositions(instance);\n        }, 0);\n    }\n\n    private _updateElementPositions(instance: WalkthroughContainerComponent) {\n        if (WalkthroughComponent._walkthroughContainer && this._getInstance()) {\n            setTimeout(() => {\n                instance.contentBlockPosition(\n                    this._offsetCoordinates,\n                    this._alignContent,\n                    this._verticalAlignContent,\n                    this._contentSpacing,\n                    this._verticalContentSpacing\n                );\n                if (this._offsetCoordinates && this._focusElement !== null && this._hasArrow) {\n                    instance.arrowPosition(\n                        this._offsetCoordinates,\n                        this._verticalContentSpacing\n                    );\n                }\n\n                // add CSS to focusElement\n                if (this.focusElementCSSClass) {\n                    this._renderer.addClass(this._focusElement, this.focusElementCSSClass);\n                }\n\n                setTimeout(() => {\n                    this._getInstance().setHeight();\n\n                    if (!this._readyHasBeenEmited) {\n                        this._readyHasBeenEmited = true;\n                        this.ready.emit(new WalkthroughEvent(this, this._focusElement));\n                    }\n\n                    const contentBlockNative = instance.contentBlock.nativeElement as HTMLElement;\n                    let scrollPos;\n\n                    if (this._focusElement != null) {\n                        const coordinatesContent = this._walkthroughService.retrieveCoordinates(contentBlockNative);\n                        const coordinatesFocus = this._walkthroughService.retrieveCoordinates(this._focusElement);\n                        // is content + focus higher than window ?\n                        if (coordinatesContent.height + coordinatesFocus.height > window.innerHeight) {\n                            // we scroll on content\n                            contentBlockNative.scrollIntoView(true);\n                            // we offset the window half of the content height\n                            if (coordinatesContent.top > coordinatesFocus.top) {\n                                // content below focusZone\n                                scrollPos = -(coordinatesContent.height / 2);\n                            } else {\n                                // content above focusZone\n                                scrollPos = +(coordinatesContent.height / 2);\n                            }\n                        } else {\n                            // scroll on element higher minus minimal margin\n                            if (coordinatesContent.top > coordinatesFocus.top) {\n                                window.scrollTo(coordinatesFocus.left, coordinatesFocus.top);\n                                scrollPos = -WalkthroughComponent.minimalMargin;\n                            } else {\n                                contentBlockNative.scrollIntoView(true);\n                                scrollPos = -WalkthroughComponent.minimalMargin;\n                            }\n                        }\n                    } else {\n                        // no focus zone, scroll on content minus margin\n                        contentBlockNative.scrollIntoView(true);\n                        scrollPos = -WalkthroughComponent.minimalMargin;\n                    }\n\n                    window.scrollBy(0, scrollPos);\n                }, 50);\n            }, 0);\n        }\n    }\n\n    /**\n     * Attache the template in the contener, if a template is linked.\n     */\n    private _attachContentTemplate() {\n        if (this.contentTemplate) {\n            this._attachWalkthroughContent(\n                this.contentTemplate,\n                this._getInstance()\n            );\n        }\n    }\n\n    /**\n     * init a partof styles of the contenaire\n     */\n    private _initStylingTemplate(instance: WalkthroughContainerComponent) {\n        const hasHighlightZone = this._focusElement !== null;\n\n        instance.parent = this;\n        instance.open();\n        instance.hasHighlightZone = hasHighlightZone;\n        instance.hasClickable = hasHighlightZone && typeof this.focusClick === 'function';\n        instance.hasHighlight = hasHighlightZone && this._hasHighlightAnimation;\n        instance.hasBackdrop = this._hasBackdrop;\n        instance.hasGlow = hasHighlightZone && this._hasGlow;\n\n    }\n\n\n    /**\n     * init all datas of the contenaire\n     */\n    private _initContentTemplate(instance: WalkthroughContainerComponent) {\n        const hasHighlightZone = this._focusElement !== null;\n\n        instance.hasPrevious = this._hasPreviousStep(instance);\n        instance.hasNext = this._hasNextStep(instance);\n        instance.hasCloseButton = this._hasCloseButton;\n        instance.hasCloseAnywhere = this._hasCloseAnywhere;\n        instance.hasFinish = this._hasFinish || !instance.hasNext;\n        instance.hasArrow = hasHighlightZone && this._hasArrow;\n        instance.arrowColor = this.arrowColor;\n        instance.radius = this.radius;\n        instance.marginZone = this._marginZone ? this._marginZone.replace(/(\\d+)/g, '$1px') : null;\n        instance.marginZonePx = this._marginZonePx;\n        instance.contentText = this.contentText;\n        instance.contentStyle = this.contentStyle;\n        instance.text = this.texts\n            ? { ...new WalkthroughText(), ...this.texts }\n            : new WalkthroughText();\n\n        this._show();\n    }\n\n    /**\n     * check if there is a previous step enabled\n     */\n    private _hasPreviousStep(instance: WalkthroughContainerComponent): boolean {\n        if (instance.parent) {\n            let current = instance.parent.previousStep;\n            while (current) {\n                if (!current.disabled) {\n                    return true;\n                }\n                current = current.previousStep;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * check if there is a next step enabled\n     */\n    private _hasNextStep(instance: WalkthroughContainerComponent): boolean {\n        if (instance.parent) {\n            let current = instance.parent.nextStep;\n            while (current) {\n                if (!current.disabled) {\n                    return true;\n                }\n                current = current.nextStep;\n            }\n        }\n\n        return false;\n    }\n}\n","import {\n    Component,\n    Input,\n    ContentChildren,\n    QueryList,\n    AfterViewInit,\n    Output,\n    EventEmitter\n} from '@angular/core';\n\nimport { booleanValue, WalkthroughEvent } from './walkthrough-tools';\nimport { WalkthroughText } from './walkthrough-text';\nimport { WalkthroughComponent } from './walkthrough.component';\n\nlet nextUniqueId = 0;\n\n@Component({\n    selector: 'ng-walkthrough-flow',\n    template: ''\n})\nexport class WalkthroughFlowComponent implements AfterViewInit {\n\n    @ContentChildren(WalkthroughComponent) walkthroughComponents: QueryList<WalkthroughComponent>;\n\n    @Input()\n    get id() { return this._id; }\n    set id(value: string) { this._id = value || this._uid; }\n\n    @Output() closed: EventEmitter<boolean> = new EventEmitter<boolean>();\n    @Output() finished: EventEmitter<WalkthroughEvent> = new EventEmitter();\n    @Input() contentStyle: 'none' | 'draken' = 'draken';\n\n    @Input() arrowColor: string;\n    @Input() marginZone: string | null = null;\n    @Input() showArrow: string | boolean;\n\n    @Input() rootElement: string;\n\n    @Input() closeButton: string | boolean;\n    @Input() closeAnywhere: string | boolean;\n    @Input() finishButton: string | boolean;\n\n    @Input() focusBackdrop: string | boolean;\n    @Input() focusGlow: string | boolean;\n    @Input() radius: string;\n\n    @Input() texts: WalkthroughText;\n\n    private _id: string;\n    private _uid = `walkthrough-flow-${nextUniqueId++}`;\n\n    constructor() { }\n\n    ngAfterViewInit() {\n        setTimeout(() => {\n            this.init();\n        }, 0);\n    }\n\n    init() {\n        let prevComp: WalkthroughComponent = null;\n        this.walkthroughComponents.forEach((walkthrough: WalkthroughComponent) => {\n\n            // navigation auto (ignore previousStep/nextStep on the WalkthroughComponent)\n\n            if (prevComp) {\n                walkthrough.previousStep = prevComp;\n                prevComp.nextStep = walkthrough;\n            }\n            prevComp = walkthrough;\n\n            // transmition (only if different from default)\n\n            if (this.closed) {\n                walkthrough.closed = this.closed;\n            }\n            if (this.finished) {\n                walkthrough.finished = this.finished;\n            }\n            if (!walkthrough.contentStyle && this.contentStyle) {\n                walkthrough.contentStyle = this.contentStyle;\n            }\n            if (!walkthrough.arrowColor && this.arrowColor) {\n                walkthrough.arrowColor = this.arrowColor;\n            }\n            if (!walkthrough.marginZone && this.marginZone) {\n                walkthrough.marginZone = this.marginZone;\n            }\n            if (!walkthrough.showArrow && booleanValue(this.showArrow)) {\n                walkthrough.showArrow = this.showArrow;\n            }\n            if (!walkthrough.rootElement && this.rootElement) {\n                walkthrough.rootElement = this.rootElement;\n            }\n            if (!walkthrough.closeButton && booleanValue(this.closeButton)) {\n                walkthrough.closeButton = this.closeButton;\n            }\n            if (walkthrough.closeAnywhere && !booleanValue(this.closeAnywhere)) {\n                walkthrough.closeAnywhere = this.closeAnywhere;\n            }\n            if (!walkthrough.finishButton && booleanValue(this.finishButton)) {\n                walkthrough.finishButton = this.finishButton;\n            }\n            if (!walkthrough.focusBackdrop && booleanValue(this.focusBackdrop)) {\n                walkthrough.focusBackdrop = this.focusBackdrop;\n            }\n            if (!walkthrough.focusGlow && booleanValue(this.focusGlow)) {\n                walkthrough.focusGlow = this.focusGlow;\n            }\n            if (!walkthrough.radius && this.radius) {\n                walkthrough.radius = this.radius;\n            }\n            if (!walkthrough.texts && this.texts) {\n                walkthrough.texts = this.texts;\n            }\n\n        });\n        // navigation auto (close on last step)\n        prevComp.finishButton = true;\n    }\n\n    start() {\n        this.walkthroughComponents.first.open();\n    }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { PortalModule } from '@angular/cdk/portal';\n\nimport { WalkthroughFlowComponent } from './walkthrough-flow.component';\nimport { WalkthroughComponent } from './walkthrough.component';\nimport { WalkthroughService } from './walkthrough.service';\nimport { WalkthroughContainerComponent } from './walkthrough-container.component';\n\n@NgModule({\n    declarations: [\n        WalkthroughFlowComponent,\n        WalkthroughComponent,\n        WalkthroughContainerComponent\n    ],\n    exports: [\n        WalkthroughFlowComponent,\n        WalkthroughComponent,\n        WalkthroughContainerComponent\n    ],\n    imports: [\n        CommonModule,\n        PortalModule\n    ],\n    entryComponents: [\n        WalkthroughContainerComponent\n    ],\n    providers: [\n        WalkthroughService\n    ]\n})\nexport class WalkthroughModule {\n    static forRoot() {\n        return {\n            ngModule: WalkthroughModule,\n            providers: []\n        };\n    }\n}\n"],"names":["booleanValue","value","WalkthroughEvent","component","focusElement","this","WalkthroughMargin","top","right","bottom","left","undefined","points","pointsPx","match","split","map","i","parseFloat","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","throwPortalAlreadyAttachedError","Error","Portal","attach","host","throwNullPortalOutletError","hasAttached","_attachedHost","detach","throwNoPortalAttachedError","defineProperty","setAttachedHost","ComponentPortal","_super","viewContainerRef","injector","_this","call","tslib_1.__extends","TemplatePortal","template","context","templateRef","elementRef","BasePortalOutlet","_isDisposed","_attachedPortal","portal","throwNullPortalError","throwPortalOutletAlreadyDisposedError","attachComponentPortal","attachTemplatePortal","throwUnknownPortalTypeError","_invokeDisposeFn","dispose","setDisposeFn","fn","_disposeFn","DomPortalOutlet","outletElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","length","parentInjector","destroy","attachView","hostView","detachView","appendChild","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","forEach","rootNode","index","indexOf","remove","parentNode","removeChild","CdkPortal","type","Directive","args","selector","exportAs","TemplateRef","ViewContainerRef","CdkPortalOutlet","_viewContainerRef","_isInitialized","attached","EventEmitter","v","_attachedRef","ngOnInit","ngOnDestroy","ref","emit","clear","inputs","ComponentFactoryResolver","_deprecatedPortal","Input","_deprecatedPortalHost","Output","NgModule","exports","declarations","PortalModule","PortalInjector","_parentInjector","_customTokens","get","token","notFoundValue","e","window","event","preventDefault","returnValue","bind","keyCode","_preventDefault","WalkthroughService","element","margin","clientrect","getBoundingClientRect","style","getComputedStyle","coordinates","height","width","marginTop","marginRight","marginBottom","marginLeft","getTop","pageYOffset","document","documentElement","scrollTop","body","body_height","Math","max","scrollHeight","offsetHeight","clientHeight","getHeightOfPage","topOfPage","heightOfPage","elementY","parent","offsetTop","scrollIntoView","scrollBy","current","getScrollParent","offsetLeft","offsetWidth","scrollLeft","element1","element2","element1Position","retrieveCoordinates","element2Position","minX","min","minY","scrollTo","scrollParent","excludeStaticParent","position","parent_1","parentElement","_overflowRegex","test","overflow","overflowY","overflowX","innerHeight","Injectable","WalkthroughText","is_safari","navigator","userAgent","_walkthroughService","_renderer","_el","WalkthroughContainerComponent","id","show","hasCloseAnywhere","hasHighlightZone","hasBackdrop","close","hasClickable","focusClick","_portalHost","throwWalkthroughContentAlreadyAttachedError","setStyle","nativeElement","getDocumentHeight","coordinate","scrollDiff","animation","animationDelays","continueFunction","zone","zoneStyle","hideOther","intervale","left_1","parseInt","top_1","width_1","height_1","partLeft_1","partTop_1","partWidth_1","partHeight_1","count_1","borderRadius","timer_1","setInterval","clearInterval","radius","Number","elementStyle","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","alignContent","verticalAlignContent","contentSpacing","verticalContentSpacing","contentBlock","elementSize","notEnoughSpace","spaceLeft","spaceRight","innerWidth","space","startLeft","_arrowPosition","WalkthroughComponent","minimalMargin","_contentPosition","centerTop","centerLeft","contentBlockElement","contentBlockCoordinates","startTop","endLeft","endTop","marginZonePx","arrowPath","arrowMarkerDist","directStartLeft","directStartTop","pause","unpause","focusElementSelector","querySelector","refresh","markerUrl","location","href","previousStep","disabled","loadPrevioustStep","nextStep","loadNextStep","finishLink","closeWalkthrough","hide","Component","styles","Renderer2","ElementRef","ViewChild","PortalHostDirective","HostBinding","HostListener","BasePortalHost","nextUniqueId","_applicationRef","_injector","_marginZone","_marginZonePx","parsePoints","_arrowColor","color","_getInstance","arrowColor","_id","_uid","_alignContent","_updateElementPositions","_verticalAlignContent","_contentSpacing","_verticalContentSpacing","_hasCloseButton","_hasCloseAnywhere","_hasArrow","_hasFinish","_hasHighlightAnimation","_hasBackdrop","_hasGlow","_disabled","instance","setTimeout","hasPrevious","_hasPreviousStep","hasNext","_hasNextStep","hasFinish","_walkthroughContainer","stop","continue","next","previous","_display","_windowWidth","walkthroughHasPause","_elementLocations","_walkthroughContainerCreating","_appendComponentToBody","closedEvent","finishedEvent","closed","finished","open","console","warn","_next","focusElementCSSClass","removeClass","_focusElement","domElem","componentOrTemplateRef","walkthroughContainer","injectionTokens","WeakMap","set","_getFocusElement","scrollIntoViewIfOutOfView","rootElement","_offsetCoordinates","typeSelector","offsetEndCoordinatesEnd","_focusElementEnd","_setFocus","focusElements","querySelectorAll","error","l","scrollY_1","pageXOffset","_initStylingTemplate","hightlightZone","_setFocusContinue","_attachContentTemplate","_initContentTemplate","hightlightZoneStyling","contentBlockPosition","arrowPosition","addClass","setHeight","_readyHasBeenEmited","ready","scrollPos","contentBlockNative","coordinatesContent","coordinatesFocus","contentTemplate","_attachWalkthroughContent","hasHighlight","hasGlow","hasCloseButton","hasArrow","marginZone","replace","contentText","contentStyle","text","texts","_show","ApplicationRef","Injector","WalkthroughFlowComponent","init","prevComp","walkthroughComponents","walkthrough","showArrow","closeButton","closeAnywhere","finishButton","focusBackdrop","focusGlow","first","ContentChildren","WalkthroughModule","ngModule","providers","imports","CommonModule","entryComponents"],"mappings":"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"}